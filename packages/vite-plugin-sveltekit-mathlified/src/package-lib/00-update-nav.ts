import { outputFile } from 'fs-extra/esm';
import { readdirSync, readFileSync } from 'node:fs';
import path from 'node:path';
import * as prettier from 'prettier';
import {
  capFirst,
  date,
  extractFrontmatter,
  getCollections,
  type Collection,
  fileToName,
  fileCompareFunction
} from './utils.js';
import type { NavNode } from './00-types.js';

const generateString = `// generated by Mathlified on ${date}\n`;
const typeString = readFileSync(path.join('src/package-lib/00-types.ts'), {
  encoding: 'utf-8'
});
const outputPath = path.join('src/lib/components/nav.ts');

export async function updateNav(autoNav: boolean): Promise<void> {
  const collections = getCollections();
  let navString = '';
  let sequentialNavString = '';
  for (const collection of collections) {
    const navNode = crawlCollection(collection);
    navString += `export const ${collection.name}Nav: NavNode = ${JSON.stringify(navNode)};`;
    //navNodes.push(navNode);
    // output directory file
    const directory = buildDirectory(navNode);
    outputDirectory(collection.name, directory.directory);
    //sequentialNavArray.push(...directory.directoryList);
    sequentialNavString +=
      `export const ${collection.name}Sequential: { name: string; slug: string }[]` +
      `=${JSON.stringify(directory.directoryList)};`;
  }
  //const navString = `export const nav = ${JSON.stringify(navNodes)};`;
  //const sequentialNavString = `export const sequentialNav = ${JSON.stringify(sequentialNavArray)};`;
  const finalExports =
    `export const nav = [${collections.map((c) => c.name + 'Nav').join(',')}];` +
    `export const sequentialNav = [${collections.map((c) => `...${c.name}Sequential`)}];`;
  const file = await prettier.format(
    generateString + typeString + navString + sequentialNavString + finalExports,
    {
      parser: 'typescript'
    }
  );
  if (autoNav) {
    return outputFile(outputPath, file);
  }
  return;
}

function crawlCollection(collection: Collection, slug = '/', fileSlug: string = path.sep) {
  const result: NavNode = {
    name: capFirst(collection.name).replaceAll('-', ' '),
    slug: `${slug}${collection.name}`,
    fileSlug: path.join(fileSlug, collection.filename)
  };
  const children: NavNode[] = [];
  // Read the contents of the directory
  const collectionPath = path.join('src/content', fileSlug, collection.filename);
  const files = readdirSync(collectionPath, { withFileTypes: true });
  for (const file of files) {
    if (file.isDirectory()) {
      children.push({
        ...crawlCollection(
          { name: fileToName(file.name), filename: file.name },
          `${slug}${collection.name}/`,
          path.join(fileSlug, collection.filename)
        )
      });
    } else if (
      !file.name.startsWith('_') &&
      (file.name.endsWith('.md') || file.name.endsWith('.ts'))
    ) {
      let name: string | undefined;
      if (file.name.endsWith('.md')) {
        const { metadata } = extractFrontmatter(
          readFileSync(path.join(collectionPath, file.name), 'utf-8')
        );
        name = metadata['title'];
      } else if (file.name.endsWith('.ts')) {
        // is there a better method to do this?
        const code = readFileSync(path.join(collectionPath, file.name), 'utf-8');
        const matchTitle = code.match(/export\s+const\s+title\s*=\s*(['"`])(.*?)\1/);
        if (matchTitle) {
          name = matchTitle[2];
        }
      }
      const canonicalFileName = fileToName(file.name.slice(0, -3));
      children.push({
        name: capFirst(name ?? canonicalFileName.replaceAll('-', ' ')),
        slug: `${slug}${collection.name}/${canonicalFileName}`,
        fileSlug: path.join(fileSlug, collection.filename, file.name.slice(0, -3))
      });
    }
  }
  children.sort((a, b) => fileCompareFunction(a.fileSlug, b.fileSlug));
  if (children.length > 0) {
    result.children = children;
  }
  return result;
}

interface DirectoryResult {
  directory: Record<string, string>;
  directoryList: { name: string; slug: string }[];
}

function buildDirectory(
  node: NavNode,
  result: DirectoryResult = { directory: {}, directoryList: [] }
): DirectoryResult {
  // If the node has children, recursively process each child
  if (node.children) {
    node.children.forEach((child) => {
      buildDirectory(child, result);
    });
  } else {
    const cleanSlug = path.join(node.slug.slice(1));
    const cleanFileSlug = node.fileSlug.slice(1);
    result.directory[cleanSlug] = cleanFileSlug;
    result.directoryList.push({ name: node.name, slug: node.slug });
  }

  return result;
}

async function outputDirectory(
  collection: string,
  slugToFile: Record<string, string>
): Promise<void> {
  const str = await prettier.format(
    `export const directory: Record<string,string> = ${JSON.stringify(slugToFile)};`,
    {
      parser: 'typescript'
    }
  );
  outputFile(path.join('src/routes', collection, 'directory.ts'), str);
}
