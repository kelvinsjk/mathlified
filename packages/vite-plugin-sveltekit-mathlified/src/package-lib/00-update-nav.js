import { outputFile } from 'fs-extra/esm';
import { readdirSync, readFileSync } from 'node:fs';
import path from 'node:path';
import * as prettier from 'prettier';
import {
  capFirst,
  date,
  extractFrontmatter,
  getCollections,
  fileToName,
  fileCompareFunction
} from './utils.js';
/** @typedef {import('./utils.js').Collection} Collection */
/** @typedef {import('./00-types.js').NavNode} NavNode */
//import type { NavNode } from './00-types.js';

const generateString = `// generated by Mathlified on ${date}\n`;
const typeString = readFileSync(path.join(import.meta.dirname, '00-types.ts'), {
  encoding: 'utf-8'
});
const outputPath = path.join('src/lib/components/nav.ts');

/**
 *
 * @param {boolean} autoNav
 * @returns {Promise<void>}
 */
//export async function updateNav(autoNav: boolean): Promise<void> {
export async function updateNav(autoNav) {
  let collections = getCollections();
  let navString = '';
  let sequentialNavString = '';
  /** @type {string[]} */
  const emptyCollections = [];
  for (const collection of collections) {
    const navNode = crawlCollection(collection);
    if (navNode !== null) {
      //! TODO: error when collection name has a hyphen
      navString += `export const ${collection.name}Nav: NavNode = ${JSON.stringify(navNode)};`;
      // output directory file
      const directory = buildDirectory(navNode);
      outputDirectory(collection.name, directory.directory);
      sequentialNavString +=
        `export const ${collection.name}Sequential: { name: string; slug: string }[]` +
        `=${JSON.stringify(directory.directoryList)};`;
    } else {
      emptyCollections.push(collection.name);
    }
  }
  collections = collections.filter((c) => !emptyCollections.includes(c.name));
  const finalExports =
    `export const nav = [${collections.map((c) => c.name + 'Nav').join(',')}];` +
    `export const sequentialNav = [${collections.map((c) => `...${c.name}Sequential`)}];`;
  const file = await prettier.format(
    generateString + typeString + navString + sequentialNavString + finalExports,
    {
      parser: 'typescript'
    }
  );
  if (autoNav) {
    return outputFile(outputPath, file);
  }
}

/**
 *
 * @param {Collection} collection
 * @param {string} slug
 * @param {string} fileSlug
 * @returns {NavNode|null}
 */
function crawlCollection(collection, slug = '/', fileSlug = path.sep) {
  /** @type {NavNode} */
  const result = {
    name: capFirst(collection.name).replaceAll('-', ' '),
    slug: `${slug}${collection.name}`,
    fileSlug: path.join(fileSlug, collection.filename)
  };
  /** @type {NavNode[]} */
  const children = [];
  // Read the contents of the directory
  const collectionPath = path.join('src/content', fileSlug, collection.filename);
  const files = readdirSync(collectionPath, { withFileTypes: true });
  for (const file of files) {
    if (file.isDirectory() && !file.name.startsWith('_')) {
      const child = crawlCollection(
        { name: fileToName(file.name), filename: file.name },
        `${slug}${collection.name}/`,
        path.join(fileSlug, collection.filename)
      );
      if (child) children.push(child);
    } else if (
      !file.name.startsWith('_') &&
      (file.name.endsWith('.md') || file.name.endsWith('.ts'))
    ) {
      /** @type {string|undefined} */
      let name;
      if (file.name.endsWith('.md')) {
        const { metadata } = extractFrontmatter(
          readFileSync(path.join(collectionPath, file.name), 'utf-8')
        );
        name = metadata['title'];
      } else if (file.name.endsWith('.ts')) {
        // is there a better method to do this?
        const code = readFileSync(path.join(collectionPath, file.name), 'utf-8');
        const matchTitle = code.match(/export\s+const\s+title\s*=\s*(['"`])(.*?)\1/);
        if (matchTitle) {
          name = matchTitle[2];
        }
      }
      const canonicalFileName = fileToName(file.name.slice(0, -3));
      children.push({
        name: capFirst(name ?? canonicalFileName.replaceAll('-', ' ')),
        slug: `${slug}${collection.name}/${canonicalFileName}`,
        fileSlug: path.join(fileSlug, collection.filename, file.name.slice(0, -3))
      });
    }
  }
  children.sort((a, b) => fileCompareFunction(a.fileSlug, b.fileSlug));
  if (children.length > 0) {
    result.children = children;
    return result;
  }
  return null;
}

/** @typedef {{directory: Record<string, string>, directoryList: { name: string; slug: string }[]}} DirectoryResult */

// interface DirectoryResult {
//   directory: Record<string, string>;
//   directoryList: { name: string; slug: string }[];
// }

/**
 *
 * @param {NavNode|null} node
 * @param {DirectoryResult} result
 * @returns {DirectoryResult}
 */
function buildDirectory(node, result = { directory: {}, directoryList: [] }) {
  if (node === null) return result;
  // If the node has children, recursively process each child
  if (node.children) {
    node.children.forEach((child) => {
      buildDirectory(child, result);
    });
  } else {
    const cleanSlug = path.join(node.slug.slice(1));
    const cleanFileSlug = node.fileSlug.slice(1);
    result.directory[cleanSlug] = cleanFileSlug;
    result.directoryList.push({ name: node.name, slug: node.slug });
  }

  return result;
}

/**
 *
 * @param {string} collection
 * @param {Record<string, string>} slugToFile
 * @returns {Promise<void>}
 */
async function outputDirectory(collection, slugToFile) {
  const str = await prettier.format(
    `export const directory: Record<string,string> = ${JSON.stringify(slugToFile)};`,
    {
      parser: 'typescript'
    }
  );
  outputFile(path.join('src/routes', collection, 'directory.ts'), str);
}
